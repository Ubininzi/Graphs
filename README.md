# Graphs

### Задание 1 [x]
Для решения всех задач курса необходимо создать класс (или иерархию классов - на усмотрение разработчика), содержащий:

1. Структуру для хранения списка смежности графа (не работать с графом через матрицы смежности, если в некоторых алгоритмах удобнее использовать список ребер - реализовать метод, создающий список рёбер на основе списка смежности);
2. Конструкторы (не менее 3-х):
- конструктор по умолчанию, создающий пустой граф [x]
- конструктор, заполняющий данные графа из файла(из матрицы смежности) [x]
- конструктор-копию (аккуратно, не все сразу делают именно копию) [x]
- специфические конструкторы для удобства тестирования [ ]
3. Методы:

- добавляющие вершину, [x]
- добавляющие ребро (дугу), [x]
- удаляющие вершину (удалить все смежные ребра), [x]
- удаляющие ребро (дугу), [x]
- выводящие список смежности в файл (в том числе в пригодном для чтения конструктором формате)(файловый ввод-вывод через матрицы смежности). [x]

Не выполняйте некорректные операции, сообщайте об ошибках.

4. Должны поддерживаться как ориентированные, так и неориентированные графы. Заранее предусмотрите возможность добавления меток и\или весов для дуг. Поддержка мультиграфа не требуется.
5. Добавьте минималистичный консольный интерфейс пользователя (не смешивая его с реализацией!), позволяющий добавлять и удалять вершины и рёбра (дуги) и просматривать текущий список смежности графа.
6. Сгенерируйте не менее 4 входных файлов с разными типами графов (балансируйте на комбинации ориентированность-взвешенность) для тестирования класса в этом и последующих заданиях. Графы должны содержать не менее 7-10 вершин, в том числе петли и изолированные вершины.

Замечание:
В зависимости от выбранного способа хранения графа могут появиться дополнительные трудности при удалении-добавлении, например, необходимость переименования вершин, если граф хранится списком (например, vector C++, List C#). Этого можно избежать, если хранить в списке пару (имя вершины, список смежных вершин), или хранить в другой структуре (например, Dictionary C#, map в С++, при этом список смежности вершины может также храниться в виде словаря с ключами - смежными вершинами и значениями - весами соответствующих ребер). Идеально, если в качестве вершины реализуется обобщенный тип (generic), но достаточно использовать строковый тип или свой класс.

### Задание 2 

К решению 1 добавить следующие возможности.

1 Реализовать статическую функцию, которая позволяет Построить полный граф на основе данного графа. Результатом должен быть объект графа. [x]
2 Реализовать статическую функцию, которая позволяет Построить граф, являющийся дополнением данного графа. Результатом должен быть объект графа. [x]
3 Реализовать статическую функцию, которая позволяет Построить граф, являющийся объединением двух заданных. Результатом должен быть объект графа. [x]
4 Реализовать статическую функцию, которая позволяет Построить граф, являющийся соединением данного графа. Результатом должен быть объект графа. [x]
 
### Задание 3
1 - Подсчитать количество сильно связных компонент Орграфа.
Орграф называется сильно связным, или сильным, если для двух любых различных его вершин х 1 и x 2 существует, по крайней мере, один путь, соединяющий эти вершины.
2 - Проверить, является ли граф деревом, или лесом, или не является ни тем, ни другим.
лес - это неориентированный ациклический граф, все связные компоненты которого являются деревьями; другими словами, граф состоит из непересекающегося объединения деревьев.

### Задание 4

 Реализовать алгоритм Краскала - построение минимального остовного дерева.


Механизм, по которому работает данный алгоритм, очень прост. На входе имеется пустой подграф, который и будем достраивать до потенциального минимального остовного дерева. Будем рассматривать только связные графы, в другом случае при применении алгоритма Краскала мы будем получать не минимальное остовное дерево, а просто остовной лес.

Вначале мы производим сортировку рёбер по неубыванию по их весам.

Добавляем i-ое ребро в наш подграф только в том случае, если данное ребро соединяет две разные компоненты связности, одним из которых является наш подграф. То есть, на каждом шаге добавляется минимальное по весу ребро, один конец которого содержится в нашем подграфе, а другой - еще нет. 

Алгоритм завершит свою работу после того, как множество вершин нашего подграфа совпадет с множеством вершин исходного графа.

Данный алгоритм называется жадным из-за того, что мы на каждом шаге пытаемся найти оптимальный вариант, который приведет к оптимальному решению в целом.